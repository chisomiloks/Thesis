\chapter{Methodology}
\label{chap:methodology}

\renewcommand{\theenumi}{\Alph{enumi}}
\renewcommand{\theenumii}{\roman{enumii}}
\begin{enumerate}
	
	\item CA Setup - This procedure is run by the CA to setup the system
	
	\begin{center}
		$ CASetup(1^{\lambda}) \longrightarrow GMK, GPP $
	\end{center}
	
	where $ 1^{\lambda} $ is the security parameter, $ GMK $ is the Global Master Key, and $ GPP $ represents the Global Public Parameters.
	
	The CA chooses two multiplicative groups $ G, G_{T} $ with the same prime order $ p $ and a bilinear map $ e \colon G \times G \rightarrow G_{T} $ and a hash function $ H \colon \{0, 1\} \rightarrow G. $ The CA chooses two random numbers $ a, b \in Z_{p} $
	
	The GMK is set as $ (a, b) $ and the GPP is set to $ (g, g^{a}, g^{b}, H) $
	
	\begin{enumerate}
		
		\item User Registration
		
		This is executed for all users in the system by the CA. Each user is assigned a globally unique $ uid $ and for each $ uid $, the CA generates two random numbers $ u_{uid}, u'_{uid} \in Z_{p} $ as its global secret keys
		
		\begin{center}
			$ GSK_{uid} = u_{uid} $, $ GSK'_{uid} = u'_{uid} $
		\end{center}
		
		The global public keys for each user is generated as 
		
		\begin{center}
			$ GPK_{uid} = g^{u_{uid}} $, $ GPK'_{uid} = g^{\frac{1}{u'_{uid}}} $
		\end{center}
		
		The CA generates a $ Certificate{uid} $ for each user $ uid $ and send $ (GPK_{uid}, GSK'_{uid}, \\ Cerificate(uid)) $ to the user.
		
		\item Attribute Authority (AA) Registration
		
		The CA assigns a globally unique authority identity $ aid $ to each AA and sends $ (GPK'_{uid}, GSK_{uid}) $ for all registered users to $ AA_{aid} $. The CA also sends the verification key $ vk_{CA} $ to $ AA_{aid} $ for verifying the $ Certificate(uid) $ assigned to each user.
		
	\end{enumerate}
	
	\item AA Setup
	
	Let $ X_{aid} $ be the set of all attributes managed by $ AA_{aid} $. The AA chooses three random numbers $ \alpha_{aid}, \beta_{aid}, \gamma_{aid} \in Z_{p} $ as its secret key.
	
	\begin{center}
		\begin{minipage}{0.5\linewidth}
			$ SK_{aid} = (\alpha_{aid}, \beta_{aid}, \gamma_{aid}) $ \\
			$ PK_{aid} = (e(g, g)^{\alpha_{aid}}, g^{\beta_{aid}}, g^{\frac{1}{\beta_{aid}}}) $
		\end{minipage}
	\end{center}
	
	For each attribute $ x_{aid} \in X_{aid} $, $ AA_{aid} $ generates a public attribute key as $ PK_{x_{aid}} = (PK_{1, x_{aid}} = H(x_{aid})^{v_{x_{aid}}}, PK_{2, x_{aid}} = H(x_{aid})^{v_{x_{aid}}\gamma_{aid}}) $ where $ v_{x_{aid}} $ is the version key of attribute $ x_{aid} $ i.e $ VK_{x_{aid}} = v_{x_{aid}} $.
	
	\item Secret Key Generation
	
	The Attribute Authority with $ AA_{aid} $ assigns a set of attributes $ S_{uid,aid} $ to user with $ uid $ after authentication and certificate verification. The AA chooses a random number $ t_{uid,aid} \in Z_{p} $ and computes a secret key for the user as
	
	$ SK_{uid,aid} = (K_{uid,aid} = g^{\frac{\alpha_{aid}}{u'_{uid}}}g^{au_{uid}}g^{bt_{uid,aid}}, K'_{uid,aid} = g^{t_{uid,aid}}, \\
	\forall x_{aid} \in S_{uid,aid} \colon K_{x_{aid},uid} = g^{t_{uid,aid}\beta_{aid}}H(x_{aid})^{v_{x_{aid}}\beta_{aid}(u_{uid} + \gamma_{aid})}) $
	
	If the user $ uid $ does not hold any attributes from $ AA_{aid} $, the user secret key $ SK_{uid,aid} $ only contains $ K_{uid,aid} $.
	
	\item Data Encryption
	
	Data is divided into components based on the level of granularity required for access control i.e $ m = \{m_{i}, \cdots, m_{n}\} $. Data components are encrypted using symmetric encryption keys $ \kappa = \{\kappa_{i}, \cdots, \kappa_{n}\} $. An access structure $ (M_{k}, \rho) $ is defined for each content key $ \kappa_{i} (i = 1, \cdots, n) $ and encrypted using the ABE scheme to produce the corresponding ciphertext. Let M be an $\ell$ x n matrix, where $\ell$ denotes the total number of all the attributes and the function $ \rho $ associates rows of M to attributes. The function $\rho$ is not required to be injective which allows for an attribute to be associated with more than one row of M.
	
	To encrypt the content key $\kappa_{i}$, the algorithm chooses a random element $ s \in Z_{p} $ which is used as the random encryption exponent. It then selects a random vector $ \vec{v} = (s, y_{2},\ldots,y_{n}) \in Z_{p} $ where $ y_{2},\ldots,y_{n} $ are used to share the encryption exponent s. It then computes $ \forall 1 \leq i \leq \ell: \lambda_{i} = \vec{v}.M_{i} $ where $ M_{i} $ is the vector corresponding to the i-th row of M. It then randomly selects $ r_{1},r_{2},\ldots,r_{\ell} $ and computes the ciphertext as
	
	$ CT_{K_{i}} = (C = K_{i}.(\prod\limits_{aid_{k} \in I_{A}}PK_{aid_{k}})^{s}, C' = g^{s}, C'' = g^{bs},	\forall 1 \leq i \leq \ell, \rho(i) \in X_{aid_{k}} \colon C_{i} = g^{a\lambda_{i}.(PK_{i,\rho(i)})^{-r_{i}}}, C'_{i} = g^{r_{i}},	D_{i} = g^{\frac{r_{i}}{\beta_{aid_k}}}, D'_{i} = (PK_{2,\rho_{(i)}})^{r_{i}}) $
	
	Then the encrypted data is uploaded to the cloud server by the owner.
	
	\item Data Decryption
	$\kappa$
	\begin{enumerate}
		
		\item Token Generation
	
	\end{enumerate}
	
	
	
\end{enumerate}
